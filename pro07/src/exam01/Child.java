package exam01;

public class Child extends Parent {//자식이 부모의 기본생성자도 생성한다.
	public Child(int number) {
		super(number); // 부모 생성자를 명시
	}//부모의 클래스에 기본생성자 없이 매개변수가 있는 생성자만 있는 경우 자식에서 부모를 생성할 때 사용할 기본 생성자가 없기 때문에 문제가 발생할 수 있다.
	 //하지만 자식에서 super()키워드로 매개변수가 있는 부모 생성자를 명시하면 문제를 해결할 수 있다.
	
	// 부모의 기능은 상속 받을거지만 시키는데로가아니라 내가 하고싶은데로 좀 변형하고 싶다.
	//안해도 상관 없지만 오버라이딩이 가능한 메서드인지 확인하기 위한 용도로 쓰인다.
	@Override// 오버로드랑 같이있으면 헤깔려진다 가능하면 표기하자.
	public int getNumber() {//오버라이드 : 부모가 가진 메서드와 동일하게 정의를한다.(접근제한자, 반환타입, 메서드명, 변수 다 똑같이(입력 순서도 똑같이)
		System.out.println("자식의 getNumber 메서드 시작");
		int num = super.getNumber(); //this는 자신(자신의 멤버변수를쓰겠다) super는 부모(부모의 변수 및 메소드를 쓰겠다)
		System.out.println("자식의 getNumber 메서드 끝");
		return num +10; // super는 오브젝트 즉 상속한 상위 클래스 부모클래스 의미. 부모를 명시한다.
	}//오버라이드를 활용하면 기존 부모 기능을 재지정할 수 있다.
	//super는 부모의 기능을 사용하면서 로직을 더 추가하고 싶을때 사용한다.
	//super키워드 안쓰면 자식메서드가 우선이다.
	
/*
 * 접근범위 = 자식은 오버라이딩시 부모 메소드의 접근범위보다 넓거나 같아야한다.
 * 1. public
 * 2. default
 * 3. protected
 * 4. private
 * 4 -> 2 -> 3 -> 1 순으로 범위가 크다 4번이 제일작고 1번이 제일큼
 */
}
